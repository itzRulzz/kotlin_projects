/*
Написать программу, реализующую шифровку и расшифровку сообщения методом омофонической замены. На входе программа запрашивает исходное сообщение. В результате работы программа выводит на консоль исходное сообщение, зашифрованное сообщение состоящее из цифр разбитых в группы по три цифры и пробела между группами и шифровальную таблицу. Шифровальную таблицу допускается выводить на консоль в виде строк, где каждая строка состоит из символа алфавита и соответствующего набора чисел разделенных пробелами. Каждое число состоит из трех знаков. Если число меньше 100, то оно дописывается до трех знаков путем добавления нулей перед числом.

Шифровальная таблица составляется путем сопоставления букве алфавита набора случайных неповторяющихся чисел от 0 до 999. Количество случайных чисел для каждой буквы алфавита равно коэффициенту вероятности умноженному на 1000. Числа также не повторяются для всей таблицы. Можно использовать типовую таблицу - то есть для символа 'А' используются строки от "000" до "068", так как вероятность появления символа 'А' равна 0.069. Для символа 'Б' используются строки от "069" до "081" и т.д. Для символа 'Я' используются строки от "837" до "853". Для символа ПРОБЕЛ используются строки от "854" до "999".

Каждая буква шифруется набором из трех цифр. Если букве сопоставляется число, состоящее менее, чем из трех знаков, то перед числом дописываются нули. Если одна и та-же буква повторяется в исходном сообщении несколько раз, то для ее замены используются разные и не повторяющиеся числа из соответствующего набора. В случае, если количество повторений буквы больше, чем чисел в наборе, то возможно повторное использование чисел из соответствующего набора, но до тех пор, пока набор не исчерпает себя и т.д.

Для дешифровки можно использовать типовую таблицу в которой строки из чисел расположены по порядку. Естественно, что шифруем тогда тоже с использованием типовой таблицы.

При шифровании символ исходного сообщения заменяется на любую шифрозамену из своего столбца. Если символ встречается повторно, то, как правило, используют разные шифрозамены. Например, исходное сообщение «АБРАМОВ» после шифрования может выглядеть «357 990 374 678 037 828 175».

Вероятность появления букв русского алфавита
Буква	Вероятность
А	0,069
Б	0,013
В	0,038
Г	0,014
Д	0,024
Е,Ё	0,071
Ж	0,007
З	0,016
Буква	Вероятность
И	0,064
Й	0,010
К	0,029
Л	0,039
М	0,027
Н	0,057
О	0,094
П	0,026
Буква	Вероятность
Р	0,042
С	0,046
Т	0,054
У	0,023
Ф	0,003
Х	0,008
Ц	0,005
Ч	0,012
Буква	Вероятность
Ш	0,006
Щ	0,004
Ъ	0,001
Ы	0,015
Ь	0,013
Э	0,002
Ю	0,005
Я	0,017
(*) (В таблице представлены результаты частотного анализа художественных и научно-технических текстов общим объёмом более 1 млн символов. При этих же условиях вероятность «пробела» составляет 0,146.)

Так как вероятность встретить самую редкую букву примерно равна одной тысячной, шифрование методом омофонической замены открытого текста можно осуществить по таблице шифрозамен, где каждая шифрозамена состоит из 3 цифр и их общее количество равно 1000. В таком случае для самого редкого элемента понадобится ровно один символ.

Пример такой таблицы представлен ниже.

№	А	Б	В	…	Е	…	О	П	Р	…	Э	Ю	Я
1	012	128	325	…	037	…	064	058	265	…	501	064	106
2	659	556	026	…	700	…	149	073	333	…	248	749	098
…	…	…	…	…	…	…	…	…	…	…		…	…
17	111		061	…	144	…	903	656	476	…			453
…	…		…	…	…	…	…	…	…	…
38	366		804	…	…	…	123		865	…
…	…			…	…	…	…		…	…
69	095				…		010
…					…		…
71					541		268
…							…
94							479
Некоторые поля в таблице пусты, так как для каждого символа исходного алфавита количество замен различно. Например, по этому фрагменту можно зашифровать слово «ВЕРА». Каждую букву исходного сообщения, в данном случае слова, следует заменить на одну из шифрозамен в столбце этой буквы.
*/

fun getMessage(): String {
    while (true) {
        print("Введите сообщение: ")
        val message = readlnOrNull()
        if (!message.isNullOrEmpty()) {
            return message.uppercase()
        }
        println("Сообщение не может быть пустым!")
    }
}

fun getChoice(): String {
    while (true) {
        print("Выберите задачу (расшифровать/зашифровать): ")
        val choice = readlnOrNull()?.uppercase()
        if (choice != null && (choice == "РАСШИФРОВАТЬ" || choice == "ЗАШИФРОВАТЬ")) {
            return choice
        }
        println("Выбор не может быть пустым! Введите 'расшифровать' или 'зашифровать'!")
    }
}

fun encrypt(message: String, cipherTable: Map<Char, List<Int>>): String {
    return message.map { char ->
        val numbers = cipherTable[char] ?: throw IllegalArgumentException("Неизвестный символ: $char")
        val number = numbers.random()
        String.format("%03d", number)
    }.joinToString(" ")
}

fun decrypt(encryptedMessage: String, cipherTable: Map<Char, List<Int>>): String {
    val cipherTableFlipped = cipherTable.entries.flatMap { (char, numbers) ->
        numbers.map { it to char }
    }.toMap()

    return encryptedMessage.split(" ").map { numberStr ->
        val number = numberStr.toInt()
        cipherTableFlipped[number] ?: throw IllegalArgumentException("Неизвестное число: $number")
    }.joinToString("")
}

fun main(){
    val alphabetProbabilities = mapOf(
        'А' to 0.069,
        'Б' to 0.013,
        'В' to 0.038,
        'Г' to 0.014,
        'Д' to 0.024,
        'Е' to 0.071,
        'Ё' to 0.071,
        'Ж' to 0.007,
        'З' to 0.016,
        'И' to 0.064,
        'Й' to 0.010,
        'К' to 0.029,
        'Л' to 0.039,
        'М' to 0.027,
        'Н' to 0.057,
        'О' to 0.094,
        'П' to 0.026,
        'Р' to 0.042,
        'С' to 0.046,
        'Т' to 0.054,
        'У' to 0.023,
        'Ф' to 0.003,
        'Х' to 0.008,
        'Ц' to 0.005,
        'Ч' to 0.012,
        'Ш' to 0.006,
        'Щ' to 0.004,
        'Ъ' to 0.001,
        'Ы' to 0.015,
        'Ь' to 0.013,
        'Э' to 0.002,
        'Ю' to 0.005,
        'Я' to 0.017,
        ' ' to 0.146
    )

    val cipherTable = mutableMapOf<Char, List<Int>>()
    var currentNumber = 0
    for ((char, probability) in alphabetProbabilities) {
        val numberOfNumbers = (probability * 1000).toInt()
        val numbers = List(numberOfNumbers) { currentNumber + it }
        cipherTable[char] = numbers
        currentNumber += numberOfNumbers
    }

    while (true) {
        try {
            val message = getMessage()
            val choice = getChoice()

            when (choice) {
                "ЗАШИФРОВАТЬ" -> {
                    val encryptedMessage = encrypt(message, cipherTable)
                    println("Зашифрованное сообщение: $encryptedMessage")
                }
                "РАСШИФРОВАТЬ" -> {
                    val decryptedMessage = decrypt(message, cipherTable)
                    println("Расшифрованное сообщение: $decryptedMessage")
                }
            }
            break
        } catch (e: IllegalArgumentException) {
            println("Ошибка: ${e.message}")
        }
    }
}
